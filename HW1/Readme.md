# Преамбула

Было реализовано 3 способа QuickSort:

- SEQ - последовательный
- PAR - параллельный с параллельными примитивами (pfor, map, scan, filter)
- PAR V2 - параллельный без примитивов

# Результаты замеров

## SEQ

### 10^8:

Среднее: `11376`

- `11590`
- `11654`
- `11489`
- `11347`
- `11376`

### 10^7

Среднее: `1082`

- `1098`
- `1058`
- `1084`
- `1110`
- `1061`


## PAR

### 10^7

Среднее: `7871`

- `8153`
- `7946`
- `8310`
- `7691`
- `7259`

## PAR V2

### 10^8

Среднее: `2047`

- `1730`
- `2136`
- `2111`
- `2163`
- `2096`

# Сравнение реализаций

### 10^7

|     | ms     | ratio |
|-----|--------|-------|
| SEQ | 1082   | 1.0   |
| PAR | 7871   | 0.14  |

### 10^8

|        | ms    | ratio |
|--------|-------|-------|
| SEQ    | 11376 | 1.0   |
| PAR V2 | 2047  | 5.57  |

# Выводы

Параллельная версия с параллельным фильтром работает дольше из-за того, что создается много объектов, в том числе 
и потоков при fork-join. На практике асимптотика ухудшается алокацией памяти.

В то же время, как простое распараллеливание при помощи fork-join (PAR V2), дает выигрыш больше чем в 5 раз по времени.

# Запуск

```shell
mkdir out
javac src/* -d out/
cd out
java Main
```